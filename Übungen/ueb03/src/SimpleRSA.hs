module SimpleRSA where

import Data.List.Split(chunksOf)
import Data.Char(ord, chr)

import Convert

{- Part I: RSA core functionality -}

-- | Fast modulo exponentiation: modexp a b n = (a^b) mod n
modexp :: Integer-> Integer-> Integer-> Integer
modexp a n p 
    | p <= 0 || n < 0 = 0 -- p darf nicht 0 sein, da sont eine Teilung durch 0 stattfindet. p und n duerfen auch nicht negativ sein (zumindest ergibt das fuer den hiesigen Implementierungszweck keinen Sinn.
    | n == 0 = 1 -- Dieser und der naechste Fall sind die beiden in der Aufgabenstellung erwaehnten Randfaelle.
    | n == 1 = a
    | n `mod` 2 == 0 = (modexp a (n `div` 2) p)^2 `mod` p -- Fall, falls n gerade ist. Zweifaches Aufrufen von modexp in dieser Berechnung wuerde zur Nicht-Termination fuehren.
    | otherwise      = mod (a*(modexp a (n `div` 2) p)^2) p -- Falls, falls n ungerade ist. Zweifaches Aufrufen von modexp in dieser Berechnung wuerde zur Nicht-Termination fuehren.

-- | Key is given by factor and size:
data Key  = Key { factor :: Integer, size :: Integer }

-- | Funktion, die mit Hilfe eines uebergebenen Schluessels einen Integer verschluesselt.
-- Es werden also ein Schlussel und eine ganze Zahl benoetigt und es wird eine ganze Zahl zurueckgegeben.
encrypt :: Key-> Integer-> Integer
encrypt key number = modexp number (factor key) (size key) -- Implementierung funktioniert genau wie in der Beschreibung. Durch die ganzen betrachteten Falle in modexp, kommt es hier zu keinen Problemfaellen.

-- | Funktion, die mit Hilfe eines uebergebenen Schluessels einen Integer entschluesselt.
-- Es werden also ein Schlussel und eine ganze Zahl benoetigt und es wird eine ganze Zahl zurueckgegeben.
decrypt :: Key->  Integer-> Integer
decrypt key number = modexp number (factor key) (size key) -- Implementierung funktioniert genau wie in der Beschreibung.  Durch die ganzen betrachteten Falle in modexp, kommt es hier zu keinen Problemfaellen.

{- Part II: Very simple encoding/decoding -}

-- | Funktion, die einen String mithilfe eines uebergebenen Schluessels zu einer Liste von Integern verschluesselt/
-- Es muessen also ein String und ein Schluwssel uebergeben werden.
simpleEncrypt :: Key-> String-> [Integer]
-- simpleEncrypt k str = map ((encrypt k) . toInteger . ord) str
simpleEncrypt k str = f str where
    f :: String -> [Integer]
    f str -- Funktion, die den obigen auskommentierten "map"-Aufruf umsetzt.
        | str == "" = []
        | otherwise = (encrypt k (toInteger (ord (head str)))) : f (tail str)


-- | Funktion, die eine Integer-Liste mithilfe eines uebergebenen Schluessels zu einem String entschluesselt/
-- Es muessen also eine Integer-Liste und ein Schluessel uebergeben werden.
simpleDecrypt :: Key-> [Integer]-> String
-- simpleDecrypt k list = map (chr . fromInteger . (decrypt k)) list
simpleDecrypt k list = f list where
    f :: [Integer] -> String
    f list -- Funktion, die den obigen auskommentierten "map"-Aufruf umsetzt.
        | list == [] = ""
        | otherwise  = chr (fromInteger (decrypt k (head list))) : f (tail list)


{- Part III: Realistic encoding -}

-- | Encrypt a message into a list of integers.
encryptMsg :: Key -> String-> [Integer]
-- encryptMsg key string = map ((encrypt key) . stringAsNumber) (chunksOf (chunkLength key) string)
encryptMsg key string
    | y <= 0 = [] -- Der Fall, dass die Keylaenge <= 0 ist, muss beachtet werden, da die Funktion sonst nicht terminiert.
    | otherwise = f (chunksOf (y) string)
    where
    y = chunkLength key
    f :: [String] -> [Integer]
    f list -- Anwenden der Verschluesselung auf eine Liste von Strings zu einer Liste von Integern.
        | list == [] = []
        | otherwise = encrypt key (stringAsNumber (head list)) : f (tail list)

-- | Chunk length: log to the base of 256 of the keysize.
chunkLength :: Key-> Int
chunkLength key = length (convertToBase 256 (size key)) - 1 -- Die Funktion hat immer einen Wert >= 0, sofern der Schluessel gueltig ist (also eine positive Laenge hat). Ansonsten ist sie = -1.

-- | Decrypt a message from a list of intgers.
decryptMsg :: Key-> [Integer]-> String
-- decryptMsg key list = concat (map (numberAsString . (decrypt key)) list)  
decryptMsg key list = concat (f list) where
    f :: [Integer] -> [String]
    f list
        | list == [] = []
        | otherwise  = numberAsString (decrypt key (head list)) : f (tail list)





-- Some pre-generated keys.
-- prk is the private key, pbk is publik key.

-- 64 bit key length.

prk64= Key 3753840313402143125 8646379390138290473
pbk64= Key 65537 8646379390138290473

-- 128 bit key length.

prk128= Key 18738866880350791956224399611039437953 185736406342642143469399364354931958589
pbk128= Key 65537 185736406342642143469399364354931958589

-- 256 bit key length.

prk256= Key 44103241521596666859527667339165065020233177879097893457786537469837848464593 83767400075376923807357331818775854695002967507126259234920033255776011943023
pbk256= Key 65537 83767400075376923807357331818775854695002967507126259234920033255776011943023

-- 1024 bit key length.

prk1024= Key 2060523135929180803038646152790228218463732933298240070397882562788161205001852654266344380960064769231788968436521908886754688134549711054075829110082138075781368037335645058998943819354490018582216932160865245053552485111330413379458111948856491518069649540961915332079306178894692110662126582126194684673 71601540169348209060839741736698402308302049443036457843937449372983945329907962567684735787369970721709307330023508135053680803962876147057777100947748205195919399003963978892220319560809776402090533893201709951936278242881724968224432263891482068102879403868458118348025662723147259934308051746775702959773
pbk1024= Key 65537 71601540169348209060839741736698402308302049443036457843937449372983945329907962567684735787369970721709307330023508135053680803962876147057777100947748205195919399003963978892220319560809776402090533893201709951936278242881724968224432263891482068102879403868458118348025662723147259934308051746775702959773

-- 2048 bit key length

pbk2048= Key 65537 21470490656960040408247004689370319879794713901956648384968071089560515795976014903691069192244392711595641103261430674331176760592846236826409790347262555293204026044129574326473445538119962747203184038491952156165784356544825047206289266795428406017762203236206706321335243312462467140054122774089642151267546247707266962988080565819171737689826999867835250007408669737511075637162576328227203787076909790979635744949751250807572907436070017572655876919806270772056120722932343131255972995900275041685039295598579751059951174195611464585098063713281396090736871529914145516653891289774190062404997059864464641307619
prk2048 = Key 10844175217602793804314877126246959097015194849759174484502313519623153842296749459497353881509401454850348904573853193631632237551059756857820627588762650758508117034449746552033164788704226420116462377864749810355121961426221125281526176361375645323923076877514658680478476110987993420555282023057833664175919816538415730253888126170099727906325469067190640123531938616992856275202641758854498594189687654352151729436719861643163873156954631448192772121895450806406214495207326964703908386052356674628839393958112447141737103493463577151222246279569790509227521924310679777272776196759568376996453966237211024617513 21470490656960040408247004689370319879794713901956648384968071089560515795976014903691069192244392711595641103261430674331176760592846236826409790347262555293204026044129574326473445538119962747203184038491952156165784356544825047206289266795428406017762203236206706321335243312462467140054122774089642151267546247707266962988080565819171737689826999867835250007408669737511075637162576328227203787076909790979635744949751250807572907436070017572655876919806270772056120722932343131255972995900275041685039295598579751059951174195611464585098063713281396090736871529914145516653891289774190062404997059864464641307619

-- The secret message:
secret = [16661967884884328545084682456265813063595651177032268484264087871144411376329891678155772681523360410092615677433863100444793001728528681391884903753377923023345370443789203628246262405474692611837991853241457789163724064884116453644444539963913494498012507285124103747323656237882845904416965529321521353882227149139788645787235355371439081743021125686203866516149459578425652967714037110928294196731036249381727354117818034164075453303882210187824925962830135884579273412092958265661606199509734159259644626280569879286211391138483711730493149362745532188721156055550922753721668635024299857189630266284059721182729,8953929736478988808152749960352967247762905416604905192427301143897989072789216871957091493034458571206175514626182887122151439348091840094809462077941191956982836633815134755871747603226826087152943520991061776059240846848724778420257916982223285981527927646369450443660335842057064191948524730147992598755939878646777534820496518580903133684938587744191717562830581922920123703059427220044262943988681275059566486350294305232780252637810358465548314593289587358678862512901524443978262054791956846697902691700088866409421370524657212900426505976139706734834161988088488320190996005977063686175918588505846446073288]
